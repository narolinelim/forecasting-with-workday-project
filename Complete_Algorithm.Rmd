---
title: "Complete_Algorithm"
author: "Benhao Gu"
date: "2026-01-08"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(gurobi)
library(Matrix)
```

```{r}
# Input format: DD/MM/2025, output format: an integer number 1 to 365
# Note: the year MUST be 2025
# Converts DD/MM/YYYY to day of year (1-365) relative to 2025
date_to_int <- function(date_str) {
  dt <- as.Date(date_str, format = "%d/%m/%Y")
  base <- as.Date("2025-01-01")
  return(as.numeric(dt - base) + 1)
}
```

*DATA INPUT*
```{r}
# Source Data Frame
sources <- data.frame(
  ID = c("FS001", "FS002", "FS003", "FS004", "FS005", "FS006", "FS007", "FS008", "FS009", "FS010"),
  # Here we have use I(list(...)) is because we want to store multiple categories (with different number of categories per funding source, i.e. Salary for F1, Equipement AND Salary for F2)
  Categories = I(list(
    c("Salary"), c("Equipment"), c("Travel"), c("Salary", "Travel"), 
    c("Equipment", "Travel"), c("Salary"), c("Equipment"), c("Travel"), 
    c("Salary", "Equipment"), c("Salary", "Equipment", "Travel")
  )),
  ValidFrom = c("01/02/2025", "01/02/2025", "01/03/2025", "01/02/2025", "01/04/2025", 
                "01/06/2025", "01/01/2025", "01/05/2025", "01/07/2025", "01/02/2025"),
  ValidTo = c("30/06/2025", "31/08/2025", "30/09/2025", "31/12/2025", "31/10/2025", 
              "31/12/2025", "31/12/2025", "30/11/2025", "31/12/2025", "31/12/2025"),
  Amount = c(15000, 12000, 8000, 20000, 10000, 18000, 36000, 5000, 14000, 10000)
)

sources$Categories

# Expense Data Frame
expenses <- data.frame(
  ID = c("E009", "E014", "E015", "E013", "E001", "E002", "E003", "E004", "E005", 
         "E006", "E007", "E008", "E010", "E011", "E012"),
  Category = c("Travel", "Equipment", "Travel", "Salary", "Salary", "Equipment", 
               "Travel", "Salary", "Equipment", "Travel", "Salary", "Equipment", 
               "Salary", "Equipment", "Travel"),
  Amount = c(6000, 20000, 15000, 10000, 5000, 8000, 3000, 12000, 15000, 4000, 
             8000, 10000, 15000, 12000, 5000),
  Date = c("10/08/2025", "20/12/2025", "25/12/2025", "01/01/2025", "15/02/2025", 
           "20/02/2025", "10/03/2025", "15/04/2025", "20/05/2025", "10/06/2025", 
           "15/07/2025", "20/07/2025", "15/09/2025", "20/10/2025", "10/11/2025")
)

# getting total number of funding source and expenses (NOT total amount)
n_sources <- nrow(sources)
n_expenses <- nrow(expenses)
```

*PRE-PROCESSING*
```{r}
# This is a matrix with size n_sources x n_expenses (row is each funding sources, and column is each expenses sources), such that if the payment date of the expense fall within the valid from and valid to of the funding AND categories of the expense match with the allowed category of the source, then it will be marked as 1, otherwise 0
# We build a Compatibility Matrix (Valid = 1, Invalid = 0)
compatibility <- matrix(0, nrow = n_sources, ncol = n_expenses)

for (i in 1:n_sources) {
  for (j in 1:n_expenses) {
    # 1. Category Check
    # Expense category must be in the Source's allowed list
    cat_match <- expenses$Category[j] %in% sources$Categories[[i]]
    
    # 2. Time Validity Check
    # Convert dates to integers (Day of Year)
    s_from <- date_to_int(sources$ValidFrom[i])
    s_to   <- date_to_int(sources$ValidTo[i])
    e_date <- date_to_int(expenses$Date[j]) # Assumes this is the actual payment date
    
    # LOGIC: The payment date must be INSIDE the funding window (Inclusive)
    # ValidFrom <= PaymentDate <= ValidTo
    time_match <- (e_date >= s_from & e_date <= s_to)
    
    # Combine Checks
    if (cat_match && time_match) {
      compatibility[i, j] <- 1
    } else {
      compatibility[i, j] <- 0
    }
  }
}
```

*MODEL CONSTRUCTION*
```{r}
# Maximising logic: maximise the 
model <- list()
model$modelsense <- "max"

# --- A. Objective Function ---
# Maximise Sum(Weight_j * y_j)
# Coefficients for x[i,j] are 0. Coefficients for y[j] are the weights.
# It works because $$2^k > \sum_{i=0}^{k-1} 2^i$$, so it will always incentivise to use the funding to fulfil the expenses with higher priority

weights <- 2^(n_expenses - 1 - (0:(n_expenses-1))) # Powers of 2 descending
obj_x <- rep(0, n_sources * n_expenses)             # Zeros for x vars
model$obj <- c(obj_x, weights)                      # Combine

# --- B. Variable Types & Bounds ---
# x is Continuous ('C'), y is Binary ('B')
model$vtype <- c(rep('C', n_sources * n_expenses), rep('B', n_expenses))

# Variable Bounds (lb is 0 by default, ub is Inf)
# We use UB to enforce the "Compatibility Constraint"
# If compatibility[i,j] == 0, then x[i,j] must be 0.
ub_x <- rep(Inf, n_sources * n_expenses)
idx <- 0
for (i in 1:n_sources) {
  for (j in 1:n_expenses) {
    idx <- idx + 1
    if (compatibility[i, j] == 0) {
      ub_x[idx] <- 0
    }
  }
}
model$ub <- c(ub_x, rep(1, n_expenses)) # y vars are binary (0-1)

# --- C. Constraint Matrix (A) ---
# We will build rows for the matrix A
rows <- list()
rhs <- c()
sense <- c()

# Constraint 1: Supply (For each Source i: Sum(x_ij) <= S_i)
for (i in 1:n_sources) {
  # Create a row of zeros
  row_vec <- rep(0, n_sources * n_expenses + n_expenses)
  
  # Identify indices for x[i, *]
  # Start index for this source block
  start_idx <- (i - 1) * n_expenses + 1
  end_idx <- i * n_expenses
  
  # Set coefficients to 1 for this source's allocations
  row_vec[start_idx:end_idx] <- 1
  
  rows[[length(rows) + 1]] <- row_vec
  rhs <- c(rhs, sources$Amount[i])
  sense <- c(sense, "<=")
}

# Constraint 2: Demand Linking (For each Expense j: Sum(x_ij) - D_j * y_j = 0)
# Rearranged: Sum(x_ij) + (-D_j) * y_j = 0
for (j in 1:n_expenses) {
  row_vec <- rep(0, n_sources * n_expenses + n_expenses)
  
  # Identify indices for x[*, j] (This is strided/every Nth element)
  # Also identify index for y[j]
  
  # 1. Fill x coefficients (1 for every source pointing to this expense)
  for (i in 1:n_sources) {
    idx_x <- (i - 1) * n_expenses + j
    row_vec[idx_x] <- 1
  }
  
  # 2. Fill y coefficient (-Demand)
  idx_y <- (n_sources * n_expenses) + j
  row_vec[idx_y] <- -expenses$Amount[j]
  
  rows[[length(rows) + 1]] <- row_vec
  rhs <- c(rhs, 0)
  sense <- c(sense, "=")
}

# Combine rows into a Sparse Matrix
model$A <- do.call(rbind, rows)
model$A <- Matrix(model$A, sparse = TRUE) # Convert to sparse for Gurobi
model$rhs <- rhs
model$sense <- sense
```

*OPTIMIZE*
```{r}
result <- gurobi(model)
```

*RESULT*
```{r}
if (result$status == "OPTIMAL") {
  cat("\n============================================================\n")
  cat(sprintf("%-60s\n", "                   FINAL SOLUTION REPORT                    "))
  cat("============================================================\n")
  
  # Extract Solution Vectors
  # result$x = [ x_{1,1}, x_{1,2}, ..., x_{n,m}, {y_1, y_2, ..., y_m} ]
  sol <- result$x
  # sol_x: The first block (allocations).
  # sol_y: The second block (binary flags).
  sol_x <- sol[1:(n_sources * n_expenses)]
  sol_y <- sol[(n_sources * n_expenses + 1):length(sol)]
  
  # Reshape sol_x back to matrix for easy reading
  x_matrix <- matrix(sol_x, nrow = n_sources, ncol = n_expenses, byrow = TRUE)
  
  # --- 1. FILLED EXPENSES ---
  cat("\n--- Filled Expenses ---\n")
  # It uses > 0.5 instead of == 1 to avoid floating-point errors (e.g., 0.999999).
  filled_indices <- which(sol_y > 0.5)
  unfilled_indices <- which(sol_y < 0.5)
  
  for (j in filled_indices) {
    cat(sprintf("%s: %s ($%s)\n", 
                expenses$ID[j], expenses$Category[j], 
                format(expenses$Amount[j], big.mark=",")))
  }
  
  # --- 2. UNFILLED EXPENSES ---
  cat("\n--- nfilled Expenses ---\n")
  for (j in unfilled_indices) {
    cat(sprintf("%s: %s ($%s) - Due: %s\n", 
                expenses$ID[j], expenses$Category[j], 
                format(expenses$Amount[j], big.mark=","),
                expenses$Date[j]))
  }
  
  cat(sprintf("\nSummary: %d Filled / %d Missed\n", length(filled_indices), length(unfilled_indices)))
  
  # --- 3. ALLOCATION DETAILS ---
  cat("\n--- Allocation Details ---\n")
  cat(sprintf("%-8s %-8s %-15s %s\n", "Source", "Expense", "Exp. Category", "Amount Allocated"))
  cat("------------------------------------------------------------\n")
  
  for (i in 1:n_sources) {
    for (j in filled_indices) {
      val <- x_matrix[i, j]
      # if Source i contributed money to Expense j.
      if (val > 1e-6) {
        cat(sprintf("%-8s -> %-8s %-15s $%s\n", 
                    sources$ID[i], expenses$ID[j], expenses$Category[j], 
                    format(val, nsmall=2, big.mark=",")))
      }
    }
  }
  
  # --- 4. REMAINING BALANCES ---
  cat("\n--- Remaining Fund Balances ---\n")
  cat(sprintf("%-8s %-10s %-10s %-10s %s\n", "Fund ID", "Initial", "Used", "Remaining", "Allowed Categories"))
  cat("-----------------------------------------------------------------\n")
  
  total_unused <- 0
  for (i in 1:n_sources) {
    # calculates how much of each source was "spent."
    used <- sum(x_matrix[i, ])
    remaining <- sources$Amount[i] - used
    if (remaining < 1e-6) remaining <- 0
    total_unused <- total_unused + remaining
    
    cats_str <- paste(unlist(sources$Categories[i]), collapse = ", ")
    
  cat(sprintf("%-8s %-10s %-10s %-10s %s\n", 
                sources$ID[i], 
                format(sources$Amount[i], big.mark=",", nsmall=0), 
                format(round(used), big.mark=",", nsmall=0), 
                format(round(remaining), big.mark=",", nsmall=0), 
                cats_str))
  }
  cat("-----------------------------------------------------------------\n")
  cat(sprintf("TOTAL UNUSED FUNDS: $%s\n", format(total_unused, big.mark=",")))
  
} else {
  cat("No optimal solution found.\n")
}

```



```{r}
if (result$status == "OPTIMAL") {
  
  # --- 1. Parse Solution Vectors ---
  sol <- result$x
  sol_x <- sol[1:(n_sources * n_expenses)]
  sol_y <- sol[(n_sources * n_expenses + 1):length(sol)]
  
  # Reconstruct the allocation matrix (Rows = Sources, Cols = Expenses)
  x_matrix <- matrix(sol_x, nrow = n_sources, ncol = n_expenses, byrow = TRUE)
  
  # --- 2. Create Data Frame: Allocations (Who paid for what?) ---
  # We find indices where allocation > 0
  alloc_indices <- which(x_matrix > 1e-6, arr.ind = TRUE) # Returns matrix of [row, col]
  
  df_allocations <- data.frame(
    SourceID = sources$ID[alloc_indices[, 1]],
    ExpenseID = expenses$ID[alloc_indices[, 2]],
    ExpenseCategory = expenses$Category[alloc_indices[, 2]],
    AllocatedAmount = x_matrix[alloc_indices]
  )
  
  # --- 3. Create Data Frame: Expenses Status (Filled vs Unfilled) ---
  # We copy the original expenses and add a "Filled" boolean flag
  df_expenses_status <- expenses
  df_expenses_status$IsFilled <- sol_y > 0.5
  
  # Optional: Split if you strictly need separate inputs for next function
  # df_filled <- df_expenses_status[df_expenses_status$IsFilled == TRUE, ]
  # df_unfilled <- df_expenses_status[df_expenses_status$IsFilled == FALSE, ]
  
  # --- 4. Create Data Frame: Funds Summary (Used vs Remaining) ---
  # Calculate usage per source
  used_amounts <- rowSums(x_matrix)
  
  df_funds_summary <- data.frame(
    SourceID = sources$ID,
    InitialAmount = sources$Amount,
    UsedAmount = used_amounts,
    RemainingAmount = sources$Amount - used_amounts
  )
  
  # --- Output for verification ---
  print("Optimization Successful. Data frames created:")
  print("1. df_allocations")
  print("2. df_expenses_status")
  print("3. df_funds_summary")
  
} else {
  warning("No optimal solution found. Data frames not generated.")
}

```


```{r}
# SourceID: ID of the funding source (e.g., FS001).
# ExpenseID: ID of the expense being paid (e.g., E004).
# ExpenseCategory: The category of the expense (e.g., Salary).
# AllocatedAmount: The exact dollar amount transferred.
df_allocations
```

```{r}
# All original columns (ID, Category, Amount, Date) plus:
# IsFilled: A Boolean (TRUE/FALSE) indicating if the optimization solver selected this expense.
df_expenses_status
```

```{r}
# SourceID: ID of the fund.
# InitialAmount: The starting budget.
# UsedAmount: Total allocated in this solution (sum(x_matrix[i, ])).
# RemainingAmount: What is left over (Initial - Used).
df_funds_summary
```